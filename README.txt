
Documentation Outline:

In our main source file, scannerCSVsorter.c, we included our header file scannerCSVsorter.h because all of our functions and structs are declared inside scannerCSVsorter.h. The functions include listDirectory(), csvfilehandler(), checkcsv(), formatOutput, 4 functions for mergesorting, and struct Node. 

In scannerCSVsorter.c, the main function first checks the arguments to make sure they are in the right format. There are 3 int flags to signal the '-c', '-d', and the '-o' arguments and 3 strings that hold the input column, input directory, and output directory arguments.This code iterates through the argv[] array and copies all the arguments into either a flag variable or string variable. This function is also able to read the input column, input directory, and output directory in any order. After checking that the arguments are valid, this then calls listDirectory() to print out all processes and their respective PID's.  
	

Our listDirectory() function recursively opens the specified input directory and searches for sub-directories and files. It has 2 main conditionals to distinguish between handling a sub-directory and a file. If it finds a subdirectory, listDirectory() will fork a child process to handle searching through the subdirectory by recursively calling listDirectory(). If it finds a file, then listDirectory() will fork a child process to handle the file. Under the file handler condition, it calls the function csvfilehandler to process the file.

Our csvfilehandler() function calls function checkcsv() to check if a file is a valid csv file to call mergesort on. If checkcsv returns 0, then the file was approved and csvfilehandler will begin sorting the file. To do this, we have a loop which parses one character from the input file at a time. Inside of this we havean array buf[] which holds one row's string in multiple iterations for every row of this file.The next conditional where lineCount == 0 parses the header line of the file. There is also a short conditional where it checks if there is a " " to help handle the situation where there is a comma (,) in the column's data. Next there is a conditional where lineCount>0, which parses every other line of the CSV file. The first conditional where commaColSort == commaCount holds the logic for where to parse the column's data that we want to compare. Finally the last conditional checks for a new line character (\n) and allocates and copys the column's data as well as the row's fullString into an array of Nodes which we can use with our sorting methods. After sorting the file, csvfilehandler() then calls formatOutput() to rename the newly sorted file into the "<inputfile>-sorted-<inputColumn>.csv" format and sends the file to the specified output directory. 

Our checkcsv() function takes in a file path and checks if the file type is of ".csv". If it is a csv file, then it opens and reads the entire file to check for correct formatting of the header row and all the columns (i.e. same format as movie_metadata.csv). This does so by comparing the number of commas of each row to the header row so each row has the same number of columns

Our formatOutput() function renames a newly sorted file in the "<inputfile>-sorted-<inputColumn>.csv" format

In order to sort a file, our code provides 4 methods for sorting: 2 for mergesort on integer values and 2 for mergesort on character values. These are specific for our struct called "Node" which holds a string called fullString for the whole row's data (which is one movie's data). The struct "Node" in our header file also stores data for either an integer or string which is specific to the column we are sorting. Whether there is an integer or string stored in one of the two, depends on whether the column we are sorting by is an integer or string. 